# Cryogenic Copilot Instructions
- Cryogenic runs the original DNCDPRG.EXE inside Spice86 and replaces key routines with C# overrides; always pass `--UseCodeOverride true` when launching or your code will never run.
- Entry point `src/Cryogenic/Program.cs` only decorates the CLI args (injects `ProvidedAsmHandlersSegment`) before calling `Spice86.Program.RunWithOverrides<DuneCdOverrideSupplier>`.
- `DuneCdOverrideSupplier` just instantiates `Overrides.Overrides`; extend this partial class when adding new behavior so the override table stays centralized.
- Segment fields in `Overrides` (`cs1=0x1000` main code, `cs2/3/4` mapped driver segments, `cs5=0xF000` BIOS/IRQ) are the anchors for every injected address; never change them without auditing all `DefineFunction`/`DoOnTopOfInstruction` calls.
- Override registration happens in `DefineOverrides()` via helpers such as `DefineFunction` (replaces CALL targets) and `DoOnTopOfInstruction` (inject inline hooks); stick to those APIs so Spice86 can patch the emulated program (DNCDPRG.EXE) correctly.
- Override methods live alongside the registration, keep the generated name pattern `{Segment}_{Offset}_{Linear}` (e.g. `SetBackBufferAsActiveFrameBuffer_1000_C085_01C085`) to preserve traceability with the DOS disassembly.
- Return through `NearRet()` or `FarRet()` from `CSharpOverrideHelper` based on the original instruction (near/far RET); wrong choice will corrupt the stack.
- Use the provided `globalsOnDs`/`globalsOnCsSegment0x2538` accessors for game state instead of manual pointer math; these wrappers synchronize with the DS/CS base registers automatically.
- Anything under `src/Cryogenic/Generated/` is produced by Spice86 dump tooling (`dump/CodeGeneratorConfig.json`)—do not hand-edit; add manual accessors in `Globals/Extra*` instead.
- `DriverLoadToolbox` remaps VGA/PCM/MIDI drivers to clean 0xD000/0xE000/0xF000 boundaries and resets the allocator; when touching driver loading ensure both `RemapDrivers` and `ResetAllocator` hooks stay paired at `CS1:E57B`/`CS1:E593`.
- `DriverLoadToolbox.ReadDriverFunctionTable` auto-defines exported driver functions; let it run before introducing manual overrides inside driver segments to avoid duplicate registrations.
- Memory dumps are triggered via `DefineMemoryDumpsMapping()` using `MemoryDataExporter`; copy that pattern if you need extra snapshots while debugging reverse-engineered routines.
- Logging is done through `_loggerService.Debug` with structured templates—keep payloads terse so emulator logs remain readable during long play sessions.
- `Overrides/MenuCode.cs` exposes canonical menu type constants; reuse them instead of magic numbers when routing DNCDPRG.EXE UI logic.
- Video work happens in `Overrides/VgaDriverCode.cs`; reuse helpers like `SetDiFromXYCordsDxBx` and `VgaFunc08FillWithZeroFor64000AtES` to avoid duplicating pixel buffer math.
- For map/dialogue/time systems, follow the existing partial file split (`MapCode`, `DialoguesCode`, etc.) so new overrides stay discoverable by domain.
- Build inside `src`: `dotnet build` for validation, or `dotnet run --Exe C:/path/to/DNCDPRG.EXE --UseCodeOverride true` to execute against the DOS assets; running with audio requires the same `dotnet run` command plus `-a "ADL220 SBP2227"` or similar.
- The expected DNCDPRG checksum is `5F30AEB84D67CF2E053A83C09C2890F010F2E25EE877EBEC58EA15C5B30CFFF9`; mismatches cause Spice86 to refuse to load overrides, so verify the SHA256 before debugging.
- The repo has no automated tests—launch the game and exercise the scenario you touched to validate changes.
- If you hit `FailAsUntested` exceptions, it means the override covers an unobserved code path; either reproduce that path in-game or guard the code before shipping.
- Coordinate updates to `CodeGeneratorConfig.json` with regenerated dumps under `dump/` so address lists and injected snippets stay consistent.
- Extensive documentation is encouraged to explain the purpose and functionality of overrides, aiding future developers in understanding the codebase.
